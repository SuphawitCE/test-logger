const { Product, ProductStream } = require('../../src').ProductSchema;

const baseEvent = require('../fixtures/baseEvent.json');

describe('product schema tests', () => {
  test('should successfully pass validation', () => {
    const testEvent = baseEvent;
    const { error } = Product.validate(testEvent);
    expect(error).toBe(undefined);
  });

  test('should fail if english description is null', () => {
    const testEvent = JSON.parse(JSON.stringify(baseEvent));
    testEvent.description.en = null;

    const { error } = Product.validate(testEvent);
    expect(error.message).toEqual('"description.en" must be a string');
    expect(error.name).toEqual('ValidationError');
  });

  test('should fail if there are no variants', () => {
    const testEvent = JSON.parse(JSON.stringify(baseEvent));
    testEvent.variants = null;

    const { error } = Product.validate(testEvent);
    expect(error.message).toEqual('"variants" must be of type object');
    expect(error.name).toEqual('ValidationError');
  });

  test('should fail if image has invalid store/shop specified', () => {
    const testEvent = JSON.parse(JSON.stringify(baseEvent));

    testEvent.images.uk = {
      cover:
        'https://d2ooe7uanou0ka.cloudfront.net/img/p/2/1/7/4/8/7/217481.jpg',
      hover:
        'https://d2ooe7uanou0ka.cloudfront.net/img/p/2/1/7/4/8/7/217482.jpg',
      flatlay: null,
      smartly: null,
      marketplace: null,
      closeup: null,
      additional: []
    };

    const { error } = Product.validate(testEvent);
    expect(error.message).toEqual('"images.uk" is not allowed');
    expect(error.name).toEqual('ValidationError');
  });

  test('should fail if invalid image type specified', () => {
    const testEvent = JSON.parse(JSON.stringify(baseEvent));

    testEvent.images.th = {
      ...testEvent.images.th,
      invalidtype: 'wrong image type',
      flatlay: null,
      smartly: null,
      marketplace: null,
      closeup: null,
      additional: []
    };

    const { error } = Product.validate(testEvent);
    expect(error.message).toEqual('"images.th.invalidtype" is not allowed');
    expect(error.name).toEqual('ValidationError');
  });

  test('should fail if category is missing for en store', () => {
    const testEvent = JSON.parse(JSON.stringify(baseEvent));

    testEvent.category_1.en = null;

    const { error } = Product.validate(testEvent);
    expect(error.message).toEqual('"category_1.en" must be a string');
    expect(error.name).toEqual('ValidationError');
  });

  test('should fail if any store has invalid release_date is provided', () => {
    const testEvent = JSON.parse(JSON.stringify(baseEvent));

    testEvent.release_date.th = 'some invalid release date';

    const { error } = Product.validate(testEvent);
    expect(error.message).toEqual(
      '"release_date.th" must be in ISO 8601 date format'
    );
    expect(error.name).toEqual('ValidationError');
  });

  test('should succeed even if all stores have no release_dates', () => {
    const testEvent = JSON.parse(JSON.stringify(baseEvent));

    testEvent.release_date = {
      th: null,
      sg: null,
      my: null,
      id: null,
      ph: null,
      hk: null,
      au: null,
      gl: null
    };

    const { error } = Product.validate(testEvent);
    expect(error).toBe(undefined);
  });

  test('should fail if all store keys are not provided', () => {
    const testEvent = JSON.parse(JSON.stringify(baseEvent));

    testEvent.release_date = null;

    const { error } = Product.validate(testEvent);
    expect(error.message).toEqual('"release_date" must be of type object');
    expect(error.name).toEqual('ValidationError');
  });

  test('should fail if sub_product_line is null', () => {
    const testEvent = JSON.parse(JSON.stringify(baseEvent));

    testEvent.sub_product_line = null;

    const { error } = Product.validate(testEvent);
    expect(error.message).toEqual('"sub_product_line" must be a string');
    expect(error.name).toEqual('ValidationError');
  });

  test('should allow null prices in variants', () => {
    const testEvent = JSON.parse(JSON.stringify(baseEvent));

    testEvent.variants = {
      '77374-166273': {
        option: '3',
        barcode: '7878788787',
        prices: {
          thb: '0.00',
          usd: null,
          myr: '29.00',
          idr: '59900.00',
          hkd: null,
          aud: '9.99',
          sgd: '9.90',
          php: null
        }
      }
    };

    const { error } = Product.validate(testEvent);
    expect(error).toBe(undefined);
  });

  test('should fail validation if blank values are provided as prices in variants', () => {
    const testEvent = JSON.parse(JSON.stringify(baseEvent));

    testEvent.variants = {
      '77374-166273': {
        option: '3',
        barcode: '7878788787',
        prices: {
          thb: '0.00',
          usd: '',
          myr: '29.00',
          idr: '59900.00',
          hkd: null,
          aud: '9.99',
          sgd: '9.90',
          php: null
        }
      }
    };

    const { error } = Product.validate(testEvent);
    expect(error.message).toEqual(
      '"variants.77374-166273.prices.usd" is not allowed to be empty'
    );
    expect(error.name).toEqual('ValidationError');
  });
});

describe('product stream schema validate success fully for a valid stream', () => {
  const validProductStream = {
    ...baseEvent,
    PK: 'SAMPLE_PID',
    SK: 'SAMPLE_SK',
    metadata: {
      th: {
        shopifyProductId: 139330,
        isScheduleDateSynced: false
      }
    },
    createdAt: `${new Date()}`,
    updatedAt: `${new Date()}`,
    origin_id: undefined
  };

  test('should successfully pass validation', () => {
    const { error } = ProductStream.validate(validProductStream);
    expect(error).toBe(undefined);
  });
});

describe('product stream schema validation should fail for a invalid stream', () => {
  const productStreamWithoutSK = {
    ...baseEvent,
    PK: 'SAMPLE_PID',
    metadata: {
      th: {
        shopifyProductId: 139330,
        isScheduleDateSynced: false
      }
    },
    createdAt: `${new Date()}`,
    updatedAt: `${new Date()}`,
    origin_id: undefined
  };

  test('should fail validation', () => {
    const { error } = ProductStream.validate(productStreamWithoutSK);
    expect(error.message).toEqual('"SK" is required');
  });
});
