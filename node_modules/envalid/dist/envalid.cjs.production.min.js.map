{"version":3,"file":"envalid.cjs.production.min.js","sources":["../src/errors.ts","../src/reporter.ts","../src/core.ts","../src/middleware.ts","../src/validators.ts","../src/envalid.ts"],"sourcesContent":["// Surprisingly involved error subclassing\n// See https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n\nexport class EnvError extends TypeError {\n  constructor(message?: string) {\n    super(message)\n    Object.setPrototypeOf(this, new.target.prototype)\n    Error.captureStackTrace(this, EnvError)\n    this.name = this.constructor.name\n  }\n}\n\nexport class EnvMissingError extends ReferenceError {\n  constructor(message?: string) {\n    super(message)\n    Object.setPrototypeOf(this, new.target.prototype)\n    Error.captureStackTrace(this, EnvMissingError)\n    this.name = this.constructor.name\n  }\n}\n","/* eslint-disable no-console */\nimport { EnvMissingError } from './errors'\nimport { ReporterOptions } from './types'\n\n// The default reporter is supports a second argument, for consumers\n// who want to use it with only small customizations\ntype ExtraOptions<T> = {\n  onError?: (errors: Partial<Record<keyof T, Error>>) => void\n  logger: (output: string) => void\n}\n\nconst defaultLogger = console.error.bind(console)\n\n// Apply ANSI colors to the reporter output only if we detect that we're running in Node\nconst isNode = !!(typeof process === 'object' && process?.versions?.node)\nconst colorWith = (colorCode: string) => (str: string) =>\n  isNode ? `\\x1b[${colorCode}m${str}\\x1b[0m` : str\n\nconst colors = {\n  blue: colorWith('34'),\n  white: colorWith('37'),\n  yellow: colorWith('33'),\n}\n\nconst RULE = colors.white('================================')\n\nexport const defaultReporter = <T = any>(\n  { errors = {} }: ReporterOptions<T>,\n  { onError, logger }: ExtraOptions<T> = { logger: defaultLogger },\n) => {\n  if (!Object.keys(errors).length) return\n\n  const missingVarsOutput: string[] = []\n  const invalidVarsOutput: string[] = []\n  for (const [k, err] of Object.entries(errors)) {\n    if (err instanceof EnvMissingError) {\n      missingVarsOutput.push(`    ${colors.blue(k)}: ${err.message || '(required)'}`)\n    } else\n      invalidVarsOutput.push(\n        `    ${colors.blue(k)}: ${(err as Error)?.message || '(invalid format)'}`,\n      )\n  }\n\n  // Prepend \"header\" output for each section of the output:\n  if (invalidVarsOutput.length) {\n    invalidVarsOutput.unshift(` ${colors.yellow('Invalid')} environment variables:`)\n  }\n  if (missingVarsOutput.length) {\n    missingVarsOutput.unshift(` ${colors.yellow('Missing')} environment variables:`)\n  }\n\n  const output = [\n    RULE,\n    invalidVarsOutput.sort().join('\\n'),\n    missingVarsOutput.sort().join('\\n'),\n    colors.yellow('\\n Exiting with error code 1'),\n    RULE,\n  ]\n    .filter(x => !!x)\n    .join('\\n')\n\n  logger(output)\n\n  if (onError) {\n    onError(errors)\n  } else if (isNode) {\n    process.exit(1)\n  } else {\n    throw new TypeError('Environment validation failed')\n  }\n}\n","import { EnvError, EnvMissingError } from './errors'\nimport { CleanOptions, Spec, ValidatorSpec } from './types'\nimport { defaultReporter } from './reporter'\n\nexport const testOnlySymbol = Symbol('envalid - test only')\n\n/**\n * Validate a single env var, given a spec object\n *\n * @throws EnvError - If validation is unsuccessful\n * @return - The cleaned value\n */\nfunction validateVar<T>({\n  spec,\n  name,\n  rawValue,\n}: {\n  name: string\n  rawValue: string | T\n  spec: Spec<T> & { _parse: (input: string) => T }\n}) {\n  if (typeof spec._parse !== 'function') {\n    throw new EnvError(`Invalid spec for \"${name}\"`)\n  }\n  const value = spec._parse(rawValue as string)\n\n  if (spec.choices) {\n    if (!Array.isArray(spec.choices)) {\n      throw new TypeError(`\"choices\" must be an array (in spec for \"${name}\")`)\n    } else if (!spec.choices.includes(value)) {\n      throw new EnvError(`Value \"${value}\" not in choices [${spec.choices}]`)\n    }\n  }\n  if (value == null) throw new EnvError(`Invalid value for env var \"${name}\"`)\n  return value\n}\n\n// Format a string error message for when a required env var is missing\nfunction formatSpecDescription<T>(spec: Spec<T>) {\n  const egText = spec.example ? ` (eg. \"${spec.example}\")` : ''\n  const docsText = spec.docs ? `. See ${spec.docs}` : ''\n  return `${spec.desc}${egText}${docsText}`\n}\n\nconst readRawEnvValue = <T>(env: unknown, k: keyof T | 'NODE_ENV'): string | T[keyof T] => {\n  return (env as any)[k]\n}\n\nconst isTestOnlySymbol = (value: any): value is symbol => value === testOnlySymbol\n\n/**\n * Perform the central validation/sanitization logic on the full environment object\n */\nexport function getSanitizedEnv<T>(\n  environment: unknown,\n  specs: { [K in keyof T]: ValidatorSpec<T[K]> },\n  options: CleanOptions<T> = {},\n): T {\n  let cleanedEnv = {} as T\n  const errors: Partial<Record<keyof T, Error>> = {}\n  const varKeys = Object.keys(specs) as Array<keyof T>\n  const rawNodeEnv = readRawEnvValue(environment, 'NODE_ENV')\n\n  for (const k of varKeys) {\n    const spec = specs[k]\n\n    // Use devDefault values only if NODE_ENV was explicitly set, and isn't 'production'\n    const usingDevDefault =\n      rawNodeEnv && rawNodeEnv !== 'production' && spec.hasOwnProperty('devDefault')\n    const devDefaultValue = usingDevDefault ? spec.devDefault : undefined\n    const rawValue =\n      readRawEnvValue(environment, k) ??\n      (devDefaultValue === undefined ? spec.default : devDefaultValue)\n\n    // Default values can be anything falsy (including an explicitly set undefined), without\n    // triggering validation errors:\n    const usingFalsyDefault =\n      (spec.hasOwnProperty('default') && spec.default === rawValue) ||\n      (usingDevDefault && devDefaultValue === rawValue)\n\n    try {\n      if (isTestOnlySymbol(rawValue)) {\n        throw new EnvMissingError(formatSpecDescription(spec))\n      }\n\n      if (rawValue === undefined) {\n        if (!usingFalsyDefault) {\n          throw new EnvMissingError(formatSpecDescription(spec))\n        }\n      } else {\n        cleanedEnv[k] = validateVar({ name: k as string, spec, rawValue })\n      }\n    } catch (err) {\n      if (options?.reporter === null) throw err\n      errors[k] = err\n    }\n  }\n\n  const reporter = options?.reporter || defaultReporter\n  reporter({ errors, env: cleanedEnv })\n  return cleanedEnv\n}\n","import { CleanedEnvAccessors } from './types'\n\nexport const strictProxyMiddleware = <T extends object>(envObj: T, rawEnv: unknown) => {\n  const inspectables = [\n    'length',\n    'inspect',\n    'hasOwnProperty',\n    Symbol.toStringTag,\n    Symbol.iterator,\n\n    // For jest\n    'asymmetricMatch',\n    'nodeType',\n\n    // For libs that use `then` checks to see if objects are Promises (see #74):\n    'then',\n    // For usage with TypeScript esModuleInterop flag\n    '__esModule',\n  ]\n  const inspectSymbolStrings = ['Symbol(util.inspect.custom)', 'Symbol(nodejs.util.inspect.custom)']\n\n  return new Proxy(envObj, {\n    get(target, name: string) {\n      // These checks are needed because calling console.log on a\n      // proxy that throws crashes the entire process. This permits access on\n      // the necessary properties for `console.log(envObj)`, `envObj.length`,\n      // `envObj.hasOwnProperty('string')` to work.\n      if (inspectables.includes(name) || inspectSymbolStrings.includes(name.toString())) {\n        // @ts-expect-error TS doesn't like symbol types as indexers\n        return target[name]\n      }\n\n      const varExists = target.hasOwnProperty(name)\n      if (!varExists) {\n        if (typeof rawEnv === 'object' && rawEnv?.hasOwnProperty?.(name)) {\n          throw new ReferenceError(\n            `[envalid] Env var ${name} was accessed but not validated. This var is set in the environment; please add an envalid validator for it.`,\n          )\n        }\n\n        throw new ReferenceError(`[envalid] Env var not found: ${name}`)\n      }\n\n      return target[name as keyof T]\n    },\n\n    set(_target, name: string) {\n      throw new TypeError(`[envalid] Attempt to mutate environment value: ${name}`)\n    },\n  })\n}\n\nexport const accessorMiddleware = <T>(envObj: T, rawEnv: unknown) => {\n  // Attach is{Prod/Dev/Test} properties for more readable NODE_ENV checks\n  // Note that isDev and isProd are just aliases to isDevelopment and isProduction\n\n  // @ts-ignore attempt to read NODE_ENV even if it's not in the spec\n  const computedNodeEnv = envObj.NODE_ENV || rawEnv.NODE_ENV\n\n  // If NODE_ENV is not set, assume production\n  const isProd = !computedNodeEnv || computedNodeEnv === 'production'\n\n  Object.defineProperties(envObj, {\n    isDevelopment: { value: computedNodeEnv === 'development' },\n    isDev: { value: computedNodeEnv === 'development' },\n    isProduction: { value: isProd },\n    isProd: { value: isProd },\n    isTest: { value: computedNodeEnv === 'test' },\n  })\n  return envObj as T & CleanedEnvAccessors\n}\n\nexport const applyDefaultMiddleware = <T>(cleanedEnv: T, rawEnv: unknown) => {\n  // Note: Ideally we would declare the default middlewares in an array and apply them in series with\n  // a generic pipe() function. However, a generically typed variadic pipe() appears to not be possible\n  // in TypeScript as of 4.x, so we just manually apply them below. See\n  // https://github.com/microsoft/TypeScript/pull/39094#issuecomment-647042984\n  return strictProxyMiddleware(accessorMiddleware(cleanedEnv, rawEnv), rawEnv)\n}\n","import { Spec, ValidatorSpec } from './types'\nimport { EnvError } from './errors'\n\n// Simplified adaptation of https://github.com/validatorjs/validator.js/blob/master/src/lib/isFQDN.js\nconst isFQDN = (input: string) => {\n  if (!input.length) return false\n  const parts = input.split('.')\n  for (let part, i = 0; i < parts.length; i++) {\n    part = parts[i]\n    if (!/^[a-z\\u00a1-\\uffff0-9-]+$/i.test(part)) return false\n    if (/[\\uff01-\\uff5e]/.test(part)) return false // disallow full-width chars\n    if (part[0] === '-' || part[part.length - 1] === '-') return false\n  }\n  return true\n}\n\n// \"best effort\" regex-based IP address check\n// If you want a more exhaustive check, create your own custom validator, perhaps wrapping this\n// implementation (the source of the ipv4 regex below): https://github.com/validatorjs/validator.js/blob/master/src/lib/isIP.js\nconst ipv4Regex = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/\nconst ipv6Regex = /([a-f0-9]+:+)+[a-f0-9]+/\nconst isIP = (input: string) => {\n  if (!input.length) return false\n  return ipv4Regex.test(input) || ipv6Regex.test(input)\n}\n\nconst EMAIL_REGEX = /^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$/ // intentionally non-exhaustive\n\nexport const makeValidator = <T>(parseFn: (input: string) => T) => {\n  return function(spec?: Spec<T>): ValidatorSpec<T> {\n    return { ...spec, _parse: parseFn }\n  }\n}\n\n// The reason for the function wrapper is to enable the <T extends boolean = boolean> type parameter\n// that enables better type inference. For more context, check out the following PR:\n// https://github.com/af/envalid/pull/118\nexport function bool<T extends boolean = boolean>(spec?: Spec<T>) {\n  return makeValidator((input: string | boolean) => {\n    switch (input) {\n      case true:\n      case 'true':\n      case 't':\n      case '1':\n        return true\n      case false:\n      case 'false':\n      case 'f':\n      case '0':\n        return false\n      default:\n        throw new EnvError(`Invalid bool input: \"${input}\"`)\n    }\n  })(spec)\n}\n\nexport function num<T extends number = number>(spec?: Spec<T>) {\n  return makeValidator((input: string) => {\n    const coerced = +input\n    if (Number.isNaN(coerced)) throw new EnvError(`Invalid number input: \"${input}\"`)\n    return coerced\n  })(spec)\n}\n\nexport function str<T extends string = string>(spec?: Spec<T>) {\n  return makeValidator((input: string) => {\n    if (typeof input === 'string') return input\n    throw new EnvError(`Not a string: \"${input}\"`)\n  })(spec)\n}\n\nexport function email<T extends string = string>(spec?: Spec<T>) {\n  return makeValidator((x: string) => {\n    if (EMAIL_REGEX.test(x)) return x\n    throw new EnvError(`Invalid email address: \"${x}\"`)\n  })(spec)\n}\n\nexport function host<T extends string = string>(spec?: Spec<T>) {\n  return makeValidator((input: string) => {\n    if (!isFQDN(input) && !isIP(input)) {\n      throw new EnvError(`Invalid host (domain or ip): \"${input}\"`)\n    }\n    return input\n  })(spec)\n}\n\nexport function port<T extends number = number>(spec?: Spec<T>) {\n  return makeValidator((input: string) => {\n    const coerced = +input\n    if (\n      Number.isNaN(coerced) ||\n      `${coerced}` !== `${input}` ||\n      coerced % 1 !== 0 ||\n      coerced < 1 ||\n      coerced > 65535\n    ) {\n      throw new EnvError(`Invalid port input: \"${input}\"`)\n    }\n    return coerced\n  })(spec)\n}\n\nexport function url<T extends string = string>(spec?: Spec<T>) {\n  return makeValidator((x: string) => {\n    try {\n      new URL(x)\n      return x\n    } catch (e) {\n      throw new EnvError(`Invalid url: \"${x}\"`)\n    }\n  })(spec)\n}\n\n// It's recommended that you provide an explicit type parameter for json validation\n// if you're using TypeScript. Otherwise the output will be typed as `any`. For example:\n//\n// cleanEnv({\n//   MY_VAR: json<{ foo: number }>({ default: { foo: 123 } }),\n// })\nexport function json<T = any>(spec?: Spec<T>) {\n  return makeValidator<T>((x: string) => {\n    try {\n      return JSON.parse(x)\n    } catch (e) {\n      throw new EnvError(`Invalid json: \"${x}\"`)\n    }\n  })(spec)\n}\n","import { CleanedEnvAccessors, CleanOptions, ValidatorSpec } from './types'\nimport { getSanitizedEnv, testOnlySymbol } from './core'\nimport { applyDefaultMiddleware } from './middleware'\n\n/**\n * Returns a sanitized, immutable environment object. _Only_ the env vars\n * specified in the `validators` parameter will be accessible on the returned\n * object.\n * @param environment An object containing your env vars (eg. process.env).\n * @param specs An object that specifies the format of required vars.\n * @param options An object that specifies options for cleanEnv.\n */\nexport function cleanEnv<T>(\n  environment: unknown,\n  specs: { [K in keyof T]: ValidatorSpec<T[K]> },\n  options: CleanOptions<T> = {},\n): Readonly<T & CleanedEnvAccessors> {\n  const cleaned = getSanitizedEnv(environment, specs, options)\n  return Object.freeze(applyDefaultMiddleware(cleaned, environment))\n}\n\n/**\n * Returns a sanitized, immutable environment object, and passes it through a custom\n * applyMiddleware function before being frozen. Most users won't need the flexibility of custom\n * middleware; prefer cleanEnv() unless you're sure you need it\n *\n * @param environment An object containing your env vars (eg. process.env).\n * @param specs An object that specifies the format of required vars.\n * @param applyMiddleware A function that applies transformations to the cleaned env object\n * @param options An object that specifies options for cleanEnv.\n */\nexport function customCleanEnv<T, MW>(\n  environment: unknown,\n  specs: { [K in keyof T]: ValidatorSpec<T[K]> },\n  applyMiddleware: (cleaned: T, rawEnv: unknown) => MW,\n  options: CleanOptions<T> = {},\n): Readonly<MW> {\n  const cleaned = getSanitizedEnv(environment, specs, options)\n  return Object.freeze(applyMiddleware(cleaned, environment))\n}\n\n/**\n * Utility function for providing default values only when NODE_ENV=test\n *\n * For more context, see https://github.com/af/envalid/issues/32\n */\nexport const testOnly = <T>(defaultValueForTests: T) => {\n  return process.env.NODE_ENV === 'test' ? defaultValueForTests : ((testOnlySymbol as unknown) as T) // T is not strictly correct, but prevents type errors during usage\n}\n"],"names":["EnvError","message","Object","setPrototypeOf","prototype","Error","captureStackTrace","name","_this","constructor","TypeError","EnvMissingError","_this2","ReferenceError","defaultLogger","console","error","bind","isNode","process","_process","versions","_process$versions","node","colorWith","colorCode","str","colors","blue","white","yellow","RULE","defaultReporter","errors","logger","onError","keys","length","missingVarsOutput","invalidVarsOutput","entries","k","err","push","unshift","sort","join","filter","x","exit","testOnlySymbol","Symbol","validateVar","spec","rawValue","_parse","value","choices","Array","isArray","includes","formatSpecDescription","desc","example","docs","readRawEnvValue","env","getSanitizedEnv","environment","specs","options","cleanedEnv","varKeys","rawNodeEnv","usingDevDefault","hasOwnProperty","devDefaultValue","devDefault","undefined","usingFalsyDefault","reporter","strictProxyMiddleware","envObj","rawEnv","inspectables","toStringTag","iterator","inspectSymbolStrings","Proxy","get","target","toString","set","_target","accessorMiddleware","computedNodeEnv","NODE_ENV","isProd","defineProperties","isDevelopment","isDev","isProduction","isTest","applyDefaultMiddleware","ipv4Regex","ipv6Regex","EMAIL_REGEX","makeValidator","parseFn","input","cleaned","freeze","applyMiddleware","test","part","parts","split","i","isFQDN","isIP","JSON","parse","e","coerced","Number","isNaN","defaultValueForTests","URL"],"mappings":"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"}