function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

// Surprisingly involved error subclassing
// See https://stackoverflow.com/questions/41102060/typescript-extending-error-class
var EnvError = /*#__PURE__*/function (_TypeError) {
  _inheritsLoose(EnvError, _TypeError);

  function EnvError(message) {
    var _this;

    _this = _TypeError.call(this, message) || this;
    Object.setPrototypeOf(_assertThisInitialized(_this), (this instanceof EnvError ? this.constructor : void 0).prototype);
    Error.captureStackTrace(_assertThisInitialized(_this), EnvError);
    _this.name = _this.constructor.name;
    return _this;
  }

  return EnvError;
}( /*#__PURE__*/_wrapNativeSuper(TypeError));
var EnvMissingError = /*#__PURE__*/function (_ReferenceError) {
  _inheritsLoose(EnvMissingError, _ReferenceError);

  function EnvMissingError(message) {
    var _this2;

    _this2 = _ReferenceError.call(this, message) || this;
    Object.setPrototypeOf(_assertThisInitialized(_this2), (this instanceof EnvMissingError ? this.constructor : void 0).prototype);
    Error.captureStackTrace(_assertThisInitialized(_this2), EnvMissingError);
    _this2.name = _this2.constructor.name;
    return _this2;
  }

  return EnvMissingError;
}( /*#__PURE__*/_wrapNativeSuper(ReferenceError));

var _process, _process$versions;
var defaultLogger = /*#__PURE__*/console.error.bind(console); // Apply ANSI colors to the reporter output only if we detect that we're running in Node

var isNode = !!(typeof process === 'object' && ((_process = process) == null ? void 0 : (_process$versions = _process.versions) == null ? void 0 : _process$versions.node));

var colorWith = function colorWith(colorCode) {
  return function (str) {
    return isNode ? "\x1B[" + colorCode + "m" + str + "\x1B[0m" : str;
  };
};

var colors = {
  blue: /*#__PURE__*/colorWith('34'),
  white: /*#__PURE__*/colorWith('37'),
  yellow: /*#__PURE__*/colorWith('33')
};
var RULE = /*#__PURE__*/colors.white('================================');
var defaultReporter = function defaultReporter(_ref, _temp) {
  var _ref$errors = _ref.errors,
      errors = _ref$errors === void 0 ? {} : _ref$errors;

  var _ref2 = _temp === void 0 ? {
    logger: defaultLogger
  } : _temp,
      onError = _ref2.onError,
      logger = _ref2.logger;

  if (!Object.keys(errors).length) return;
  var missingVarsOutput = [];
  var invalidVarsOutput = [];

  for (var _i = 0, _Object$entries = Object.entries(errors); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _Object$entries[_i],
        k = _Object$entries$_i[0],
        err = _Object$entries$_i[1];

    if (err instanceof EnvMissingError) {
      missingVarsOutput.push("    " + colors.blue(k) + ": " + (err.message || '(required)'));
    } else invalidVarsOutput.push("    " + colors.blue(k) + ": " + ((err == null ? void 0 : err.message) || '(invalid format)'));
  } // Prepend "header" output for each section of the output:


  if (invalidVarsOutput.length) {
    invalidVarsOutput.unshift(" " + colors.yellow('Invalid') + " environment variables:");
  }

  if (missingVarsOutput.length) {
    missingVarsOutput.unshift(" " + colors.yellow('Missing') + " environment variables:");
  }

  var output = [RULE, invalidVarsOutput.sort().join('\n'), missingVarsOutput.sort().join('\n'), colors.yellow('\n Exiting with error code 1'), RULE].filter(function (x) {
    return !!x;
  }).join('\n');
  logger(output);

  if (onError) {
    onError(errors);
  } else if (isNode) {
    process.exit(1);
  } else {
    throw new TypeError('Environment validation failed');
  }
};

var testOnlySymbol = /*#__PURE__*/Symbol('envalid - test only');
/**
 * Validate a single env var, given a spec object
 *
 * @throws EnvError - If validation is unsuccessful
 * @return - The cleaned value
 */

function validateVar(_ref) {
  var spec = _ref.spec,
      name = _ref.name,
      rawValue = _ref.rawValue;

  if (typeof spec._parse !== 'function') {
    throw new EnvError("Invalid spec for \"" + name + "\"");
  }

  var value = spec._parse(rawValue);

  if (spec.choices) {
    if (!Array.isArray(spec.choices)) {
      throw new TypeError("\"choices\" must be an array (in spec for \"" + name + "\")");
    } else if (!spec.choices.includes(value)) {
      throw new EnvError("Value \"" + value + "\" not in choices [" + spec.choices + "]");
    }
  }

  if (value == null) throw new EnvError("Invalid value for env var \"" + name + "\"");
  return value;
} // Format a string error message for when a required env var is missing


function formatSpecDescription(spec) {
  var egText = spec.example ? " (eg. \"" + spec.example + "\")" : '';
  var docsText = spec.docs ? ". See " + spec.docs : '';
  return "" + spec.desc + egText + docsText;
}

var readRawEnvValue = function readRawEnvValue(env, k) {
  return env[k];
};

var isTestOnlySymbol = function isTestOnlySymbol(value) {
  return value === testOnlySymbol;
};
/**
 * Perform the central validation/sanitization logic on the full environment object
 */


function getSanitizedEnv(environment, specs, options) {
  var _options2;

  if (options === void 0) {
    options = {};
  }

  var cleanedEnv = {};
  var errors = {};
  var varKeys = Object.keys(specs);
  var rawNodeEnv = readRawEnvValue(environment, 'NODE_ENV');

  for (var _i = 0, _varKeys = varKeys; _i < _varKeys.length; _i++) {
    var _readRawEnvValue;

    var k = _varKeys[_i];
    var spec = specs[k]; // Use devDefault values only if NODE_ENV was explicitly set, and isn't 'production'

    var usingDevDefault = rawNodeEnv && rawNodeEnv !== 'production' && spec.hasOwnProperty('devDefault');
    var devDefaultValue = usingDevDefault ? spec.devDefault : undefined;
    var rawValue = (_readRawEnvValue = readRawEnvValue(environment, k)) != null ? _readRawEnvValue : devDefaultValue === undefined ? spec["default"] : devDefaultValue; // Default values can be anything falsy (including an explicitly set undefined), without
    // triggering validation errors:

    var usingFalsyDefault = spec.hasOwnProperty('default') && spec["default"] === rawValue || usingDevDefault && devDefaultValue === rawValue;

    try {
      if (isTestOnlySymbol(rawValue)) {
        throw new EnvMissingError(formatSpecDescription(spec));
      }

      if (rawValue === undefined) {
        if (!usingFalsyDefault) {
          throw new EnvMissingError(formatSpecDescription(spec));
        }
      } else {
        cleanedEnv[k] = validateVar({
          name: k,
          spec: spec,
          rawValue: rawValue
        });
      }
    } catch (err) {
      var _options;

      if (((_options = options) == null ? void 0 : _options.reporter) === null) throw err;
      errors[k] = err;
    }
  }

  var reporter = ((_options2 = options) == null ? void 0 : _options2.reporter) || defaultReporter;
  reporter({
    errors: errors,
    env: cleanedEnv
  });
  return cleanedEnv;
}

var strictProxyMiddleware = function strictProxyMiddleware(envObj, rawEnv) {
  var inspectables = ['length', 'inspect', 'hasOwnProperty', Symbol.toStringTag, Symbol.iterator, // For jest
  'asymmetricMatch', 'nodeType', // For libs that use `then` checks to see if objects are Promises (see #74):
  'then', // For usage with TypeScript esModuleInterop flag
  '__esModule'];
  var inspectSymbolStrings = ['Symbol(util.inspect.custom)', 'Symbol(nodejs.util.inspect.custom)'];
  return new Proxy(envObj, {
    get: function get(target, name) {
      // These checks are needed because calling console.log on a
      // proxy that throws crashes the entire process. This permits access on
      // the necessary properties for `console.log(envObj)`, `envObj.length`,
      // `envObj.hasOwnProperty('string')` to work.
      if (inspectables.includes(name) || inspectSymbolStrings.includes(name.toString())) {
        // @ts-expect-error TS doesn't like symbol types as indexers
        return target[name];
      }

      var varExists = target.hasOwnProperty(name);

      if (!varExists) {
        if (typeof rawEnv === 'object' && (rawEnv == null ? void 0 : rawEnv.hasOwnProperty == null ? void 0 : rawEnv.hasOwnProperty(name))) {
          throw new ReferenceError("[envalid] Env var " + name + " was accessed but not validated. This var is set in the environment; please add an envalid validator for it.");
        }

        throw new ReferenceError("[envalid] Env var not found: " + name);
      }

      return target[name];
    },
    set: function set(_target, name) {
      throw new TypeError("[envalid] Attempt to mutate environment value: " + name);
    }
  });
};
var accessorMiddleware = function accessorMiddleware(envObj, rawEnv) {
  // Attach is{Prod/Dev/Test} properties for more readable NODE_ENV checks
  // Note that isDev and isProd are just aliases to isDevelopment and isProduction
  // @ts-ignore attempt to read NODE_ENV even if it's not in the spec
  var computedNodeEnv = envObj.NODE_ENV || rawEnv.NODE_ENV; // If NODE_ENV is not set, assume production

  var isProd = !computedNodeEnv || computedNodeEnv === 'production';
  Object.defineProperties(envObj, {
    isDevelopment: {
      value: computedNodeEnv === 'development'
    },
    isDev: {
      value: computedNodeEnv === 'development'
    },
    isProduction: {
      value: isProd
    },
    isProd: {
      value: isProd
    },
    isTest: {
      value: computedNodeEnv === 'test'
    }
  });
  return envObj;
};
var applyDefaultMiddleware = function applyDefaultMiddleware(cleanedEnv, rawEnv) {
  // Note: Ideally we would declare the default middlewares in an array and apply them in series with
  // a generic pipe() function. However, a generically typed variadic pipe() appears to not be possible
  // in TypeScript as of 4.x, so we just manually apply them below. See
  // https://github.com/microsoft/TypeScript/pull/39094#issuecomment-647042984
  return strictProxyMiddleware(accessorMiddleware(cleanedEnv, rawEnv), rawEnv);
};

/**
 * Returns a sanitized, immutable environment object. _Only_ the env vars
 * specified in the `validators` parameter will be accessible on the returned
 * object.
 * @param environment An object containing your env vars (eg. process.env).
 * @param specs An object that specifies the format of required vars.
 * @param options An object that specifies options for cleanEnv.
 */

function cleanEnv(environment, specs, options) {
  if (options === void 0) {
    options = {};
  }

  var cleaned = getSanitizedEnv(environment, specs, options);
  return Object.freeze(applyDefaultMiddleware(cleaned, environment));
}
/**
 * Returns a sanitized, immutable environment object, and passes it through a custom
 * applyMiddleware function before being frozen. Most users won't need the flexibility of custom
 * middleware; prefer cleanEnv() unless you're sure you need it
 *
 * @param environment An object containing your env vars (eg. process.env).
 * @param specs An object that specifies the format of required vars.
 * @param applyMiddleware A function that applies transformations to the cleaned env object
 * @param options An object that specifies options for cleanEnv.
 */

function customCleanEnv(environment, specs, applyMiddleware, options) {
  if (options === void 0) {
    options = {};
  }

  var cleaned = getSanitizedEnv(environment, specs, options);
  return Object.freeze(applyMiddleware(cleaned, environment));
}
/**
 * Utility function for providing default values only when NODE_ENV=test
 *
 * For more context, see https://github.com/af/envalid/issues/32
 */

var testOnly = function testOnly(defaultValueForTests) {
  return process.env.NODE_ENV === 'test' ? defaultValueForTests : testOnlySymbol; // T is not strictly correct, but prevents type errors during usage
};

var isFQDN = function isFQDN(input) {
  if (!input.length) return false;
  var parts = input.split('.');

  for (var part, i = 0; i < parts.length; i++) {
    part = parts[i];
    if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) return false;
    if (/[\uff01-\uff5e]/.test(part)) return false; // disallow full-width chars

    if (part[0] === '-' || part[part.length - 1] === '-') return false;
  }

  return true;
}; // "best effort" regex-based IP address check
// If you want a more exhaustive check, create your own custom validator, perhaps wrapping this
// implementation (the source of the ipv4 regex below): https://github.com/validatorjs/validator.js/blob/master/src/lib/isIP.js


var ipv4Regex = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;
var ipv6Regex = /([a-f0-9]+:+)+[a-f0-9]+/;

var isIP = function isIP(input) {
  if (!input.length) return false;
  return ipv4Regex.test(input) || ipv6Regex.test(input);
};

var EMAIL_REGEX = /^[^@\s]+@[^@\s]+\.[^@\s]+$/; // intentionally non-exhaustive

var makeValidator = function makeValidator(parseFn) {
  return function (spec) {
    return _extends({}, spec, {
      _parse: parseFn
    });
  };
}; // The reason for the function wrapper is to enable the <T extends boolean = boolean> type parameter
// that enables better type inference. For more context, check out the following PR:
// https://github.com/af/envalid/pull/118

function bool(spec) {
  return makeValidator(function (input) {
    switch (input) {
      case true:
      case 'true':
      case 't':
      case '1':
        return true;

      case false:
      case 'false':
      case 'f':
      case '0':
        return false;

      default:
        throw new EnvError("Invalid bool input: \"" + input + "\"");
    }
  })(spec);
}
function num(spec) {
  return makeValidator(function (input) {
    var coerced = +input;
    if (Number.isNaN(coerced)) throw new EnvError("Invalid number input: \"" + input + "\"");
    return coerced;
  })(spec);
}
function str(spec) {
  return makeValidator(function (input) {
    if (typeof input === 'string') return input;
    throw new EnvError("Not a string: \"" + input + "\"");
  })(spec);
}
function email(spec) {
  return makeValidator(function (x) {
    if (EMAIL_REGEX.test(x)) return x;
    throw new EnvError("Invalid email address: \"" + x + "\"");
  })(spec);
}
function host(spec) {
  return makeValidator(function (input) {
    if (!isFQDN(input) && !isIP(input)) {
      throw new EnvError("Invalid host (domain or ip): \"" + input + "\"");
    }

    return input;
  })(spec);
}
function port(spec) {
  return makeValidator(function (input) {
    var coerced = +input;

    if (Number.isNaN(coerced) || "" + coerced !== "" + input || coerced % 1 !== 0 || coerced < 1 || coerced > 65535) {
      throw new EnvError("Invalid port input: \"" + input + "\"");
    }

    return coerced;
  })(spec);
}
function url(spec) {
  return makeValidator(function (x) {
    try {
      new URL(x);
      return x;
    } catch (e) {
      throw new EnvError("Invalid url: \"" + x + "\"");
    }
  })(spec);
} // It's recommended that you provide an explicit type parameter for json validation
// if you're using TypeScript. Otherwise the output will be typed as `any`. For example:
//
// cleanEnv({
//   MY_VAR: json<{ foo: number }>({ default: { foo: 123 } }),
// })

function json(spec) {
  return makeValidator(function (x) {
    try {
      return JSON.parse(x);
    } catch (e) {
      throw new EnvError("Invalid json: \"" + x + "\"");
    }
  })(spec);
}

export { EnvError, EnvMissingError, accessorMiddleware, applyDefaultMiddleware, bool, cleanEnv, customCleanEnv, defaultReporter, email, host, json, makeValidator, num, port, str, strictProxyMiddleware, testOnly, url };
//# sourceMappingURL=envalid.esm.js.map
